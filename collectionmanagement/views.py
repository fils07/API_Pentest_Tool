from django.shortcuts import render,redirect
from django.http import HttpResponse
from .models import APICollection,Endpoint
import json
from postmanparser import Collection
from django.core.files.storage import default_storage
import os
import requests
import ast
import re
# Create your views here.

def IsPostmanCollection(data):
    return 'info' in data and '_postman_id' in data['info']

def IsOasCollection(data):
    return 'swagger' in data and data['swagger']=='2.0'

def ReadOasDoc(data,name):
    baseURL =  data['schemes'][0]+'://'+data['host']+data['basePath']
    collection = APICollection(name=name,baseURL=baseURL) 
    collection.save()
    for path in data['paths'].keys():
        method = list(data['paths'][path].keys())[0] # extraire la méthode du endpoint
        requestBody = dict()
        #header = dict()
        header = ''
        url = baseURL+path
        if 'security' in data['paths'][path][method].keys():
            for s in data['paths'][path][method]['security']:
                for k in s.keys():
                    #header[k]=s[k]
                    header=header + '\n' + f'{k}'+':'+''.join(map(str,s[k]))
        if ('parameters' in data['paths'][path][method].keys()):
            if len(data['paths'][path][method]['parameters']) >= 1:
                requestAdress = data['paths'][path][method]['parameters'][0]
                if 'schema' in requestAdress.keys():
                    requestAdress = data['paths'][path][method]['parameters'][0]['schema']
                    if '$ref' in requestAdress.keys():
                        requestAdress = data['paths'][path][method]['parameters'][0]['schema']['$ref']
                        requestAdress = requestAdress.split("/")
                        requestAdress = data[requestAdress[1]][requestAdress[2]]['properties']
                        requestBody = dict()
                        for k in requestAdress.keys():
                            if 'type' in requestAdress[k].keys() :
                                requestBody[k] = requestAdress[k]['type']
                            else :
                                typeref=requestAdress[k]['$ref']
                                typeref = typeref.split("/")
                                requestBody[k]=data[typeref[1]][typeref[2]]['properties']
            endpoint = Endpoint(name=path,url=url,header=header,parameters=requestBody,verb=method,api=collection)
            endpoint.save()
            '''print(f"path : {path}")
            print(f"url : {url}")
            print(f"\t \t methode :   {method}")
            if header is not None :
                print(f"\t \t \t Header : {header}")
            if requestBody is not None :
                print(f"\t \t \t \t param : {requestBody}")'''

def ReadPostman(file):
    file_path = default_storage.save(f'{os.getcwd()}/tmp/' + file.name, file)
    collection = Collection()
    collection.parse_from_file(file_path)
    requests = collection.get_requests()
    baseURL = requests[0].header[0].value
    apiCollection=APICollection(name=file.name,baseURL=baseURL)
    apiCollection.save()
    for request in requests:
        #print(f"API Endpoint : {request.url}")
        #print(f"\t API Method : {request.method}")
        #header = dict()
        header = ""
        __header = dict()
        for h in request.header :
            __header[h.key]=h.value
            header= header + '\n' + f'{h.key}'+':'+h.value
        #print(f"\t \t Header : {header}")
        body={}
        requestBody = dict()
        if request.body :
           mode = request.body.mode
           if mode == 'raw' :
              body = request.body.raw
              body=body.split("{")
              body=body[1].split("}")
              body=body[0].split(",")
              for b in body :
                  tmp = b.split(":")
                  key=tmp[0].split("\"")[1]
                  #print(f"key {key}")
                  value=tmp[1].split("\"")[1]
                  requestBody[key]=value
           elif mode == 'urlencoded' :
              body = request.body.urlencoded
           elif mode == 'urlencoded' :
              body = request.body.formdata
           elif mode == 'graphql' :
              body = request.body.urlencoded
           elif mode == 'file' :
              body = request.body.request_body_file
           #print(f"\t \t Body : {requestBody}")
        name=request.url.replace(__header['host'],'')
        #print(__header['host'])
        endpoint = Endpoint(name=name,url=request.url,header=header,parameters=requestBody,api=apiCollection,verb=request.method)
        endpoint.save()
    default_storage.delete(file_path)

def Welcome(request,endpoint=None,collection=None):
    endpoints = dict()
    for collection in APICollection.objects.all():
        endpoints[collection.name] = Endpoint.objects.all().filter(api=collection)
    context = {
            'collections':APICollection.objects.all(),
            'endpoints':Endpoint.objects.all(),
        }
    if endpoint :
        context['endpoint'] = Endpoint.objects.filter(id=endpoint).first()
        context['url'] = Endpoint.objects.filter(id=endpoint).first().url
        context['header'] =  Endpoint.objects.filter(id=endpoint).first().header
        context['requestBody'] =  Endpoint.objects.filter(id=endpoint).first().parameters
    if request.method == 'POST' and (request.FILES.get('postmanFile') or request.FILES.get('openAPIFile')) :
        #print(request.FILES)
        if request.FILES.get('postmanFile') and request.FILES.get('postmanFile').name.endswith('json'):
           uploaded_file = request.FILES.get('postmanFile')
           # Vérifier si le fichier est une collection postman
           data=json.load(uploaded_file)
           if IsPostmanCollection(data):
               # Ajouter la collection postman
               ReadPostman(uploaded_file)
               context['readDoc']=True
               context['message']="Successfully import postman api collection"
           else:
               context['readDoc']=False
               context['message']="The selected json file is not a valid postman collection"
        elif request.FILES.get('openAPIFile') and request.FILES.get('openAPIFile').name.endswith('json'):
            uploaded_file = request.FILES.get('openAPIFile')
            data=json.load(uploaded_file)
            # Vérifier si le fichier est une collection openAPI 2.0
            if IsOasCollection(data):
                # Ajouter la collection openAPI
                ReadOasDoc(data,uploaded_file.name)
                context['readDoc']=True
                context['message']="Successfully import openapi collection"
            else :
                context['readDoc']=False
                context['message']="The selected json file is not a valid openAPI Collection, check if version is 2.0 "
        else :
            #print("not json file")
            context['readDoc']=False
            context['message']='Import only JSON File'
    elif request.method == 'POST' and request.POST.get('header'):
        method  = request.POST.get('method')
        header_str = request.POST.get('header')
        body_str = request.POST.get('body')
        url = request.POST.get('url')
        
        headers_pattern = re.compile(r"(?P<header_name>[A-Za-z-]+):(?P<header_value>.+)")
        # Initialiser le dictionnaire des en-têtes
        headers_dict = {}
        # Parser les en-têtes et les ajouter au dictionnaire
        for header in header_str.split("\n"):
            if not header:
                continue
            match = headers_pattern.match(header)
            if match:
               header_name = match.group("header_name").strip()
               header_value = match.group("header_value").strip()
               headers_dict[header_name] = header_value
        #headers = ast.literal_eval(header_str)
        body = ast.literal_eval(body_str)
        methods = {
            'GET': requests.get,
            'POST': requests.post,
            'PUT': requests.put,
            'DELETE': requests.delete
        }
        context['url']=url
        context['header']=header_str
        context['requestBody'] = body_str
        context['statusCode'] = ''
        context['responseBdoy']= ''
        if method in methods:
            try:
                # Envoyer la requête appropriée
                if method in ['POST', 'PUT']:
                    response = methods[method](url, headers=headers_dict, json=body)
                else:
                    response = methods[method](url, headers=headers_dict)

                # Retourner la réponse dans une page HTML
                context['statusCode'] = response.status_code
                context['responseBody'] = response.text
                #return HttpResponse(f"Status Code: {response.status_code}<br>Response Body: {response.text}")
            except requests.RequestException as e:
                context['statusCode']=500
                context['responseMessage'] = f"Erreur lors de l'envoi de la requête: {e}"
                #return HttpResponse(f"Erreur lors de l'envoi de la requête: {e}", status=500)
        else:
             context['statusCode'] = 400
             context['responseBody'] = "Méthode non supportée"

    return render(request,'collectionmanagement/home.html',context)