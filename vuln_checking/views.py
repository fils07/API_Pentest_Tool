import time
from django.http import HttpResponseNotAllowed, JsonResponse
from django.shortcuts import render,redirect
from collectionmanagement.views import *
from .models import *
from  .utils import *
import os
import google.generativeai as genai
from google.generativeai.types import HarmCategory, HarmBlockThreshold
from django.core.serializers.json import DjangoJSONEncoder
import ast
import random
import re

genai.configure(api_key="AIzaSyBtzqb51YGOAWy9a5zCvNcvEfST3NHvvKY")

generation_config = {
  "temperature": 0.4,
  "top_p": 0.95,
  "top_k": 64,
  "max_output_tokens": 8192,
  "response_mime_type": "application/json",
}

model = genai.GenerativeModel(
  model_name="gemini-1.5-flash",
  generation_config=generation_config,
  safety_settings = {HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT : HarmBlockThreshold.BLOCK_NONE},
  # See https://ai.google.dev/gemini-api/docs/safety-settings
  system_instruction="You're a cybersecurity expert, specializing in web API security. You have a thorough knowledge of the OWASP TOP API 2023 vulnerabilities and how best to discover and exploit them in web API requests.",
)

chat_session = model.start_chat(
  history=[
    {
      "role": "user",
      "parts": [
        "Here is a description of each of the risks listed in the OWASP TOP 10 API 2023. For each vulnerability, we have a checkpoint to verify whether the API endpoint is exposed or not. Analyze and understand this list, because your job later on will be to create modified queries to check whether or not a normal query is exposed to a vulnerability.\n\nAPI1: Broken Object Level Authorization\nCheckpoint 1: Method-Based Access Control\nTest: Attempt to access a resource using different HTTP methods (GET, PUT, DELETE, PATCH) when only one method is authorized. For example, try to modify a resource using a GET request when only PUT is allowed.\nExpected Outcome: The API should only allow access using the authorized method. Any attempt to access the resource using an unauthorized method should result in an error or access denied.\nCheckpoint 2: Content-Type Validation\nTest: Send requests with invalid or unexpected Content-Type headers. For example, send a JSON request with a Content-Type of \"text/plain\" or vice versa.\nExpected Outcome: The API should reject requests with invalid Content-Type headers.\nCheckpoint 3: UUID Predictability\nTest: If the API uses UUIDs, try to guess or predict them based on the API's implementation. For example, if the API generates UUIDs sequentially, you could potentially guess the next UUID.\nExpected Outcome: The API should generate UUIDs in a way that is not predictable or guessable.\nAPI2: Broken Authentication\nCheckpoint 1: Password Strength\nTest: Attempt to register or authenticate with weak passwords that do not meet the API's password complexity requirements (e.g., short passwords, passwords without special characters).\nExpected Outcome: The API should reject weak passwords and enforce strong password policies.\nCheckpoint 2: Authentication Rate Limiting\nTest: Attempt to authenticate multiple times with incorrect credentials within a short period.\nExpected Outcome: The API should implement rate limiting to prevent brute-force attacks. After a certain number of failed attempts, the API should temporarily block the user or IP address.\nCheckpoint 3: Token Validation\nTest: If the API uses JWT tokens, try to manipulate the token's payload or signature. If the API uses OAuth or OpenID, try to obtain unauthorized access tokens or refresh tokens.\nExpected Outcome: The API should properly validate tokens and prevent unauthorized access.\nAPI3: Broken Object Property Level Authorization\nCheckpoint 1: Excessive Data Exposure\nTest: Request a resource and analyze the API response to see if it exposes more data than necessary. For example, if you request a user's profile, check if the response includes sensitive information like their password or private messages.\nExpected Outcome: The API should only return data that is relevant to the requested resource and should not expose sensitive information.\nCheckpoint 2: Input Validation\nTest: Send requests with invalid or unexpected parameters and payloads. For example, send a request with a parameter that is not defined or with a payload that is not in the expected format.\nExpected Outcome: The API should validate all input parameters and payloads and reject requests with invalid data.\nCheckpoint 3: Server-Side Filtering\nTest: Attempt to manipulate the API's response by sending requests with parameters that could potentially bypass server-side filtering. For example, try to send a request with a parameter that could be used to retrieve sensitive data or to perform unauthorized actions.\nExpected Outcome: The API should implement server-side filtering to prevent attackers from manipulating the response.\nAPI4: Unrestricted Resource Consumption\nCheckpoint 1: Rate Limiting\nTest: Send a large number of requests to the API within a short period. Vary the requests by method, client, and IP address.\nExpected Outcome: The API should implement rate limiting to prevent denial-of-service attacks. The API should limit the number of requests that can be made from a given client or IP address within a specific time period.\nCheckpoint 2: Payload Limits\nTest: Send requests with large payloads. Try to exceed the API's payload limits.\nExpected Outcome: The API should enforce payload limits to prevent attackers from overloading the server with large requests.\nCheckpoint 3: Compression\nTest: Send requests with large payloads and analyze the response to see if the API is properly compressing the data.\nExpected Outcome: The API should compress data to reduce bandwidth usage and improve performance.\nAPI5: Broken Function Level Authorization\nCheckpoint 1: Method-Based Authorization\nTest: Attempt to perform sensitive actions (e.g., deleting a resource) by changing the HTTP method from a GET to a DELETE request.\nExpected Outcome: The API should only allow sensitive actions to be performed using the authorized HTTP method.\nCheckpoint 2: Role-Based Access Control\nTest: Attempt to access resources or perform actions that are not authorized for the user's role. For example, try to access an administrative endpoint as a regular user.\nExpected Outcome: The API should enforce role-based access control and only allow users to access resources and perform actions that are authorized for their role.\nCheckpoint 3: Administrative Endpoint Protection\nTest: Attempt to access administrative endpoints that are not intended for regular users.\nExpected Outcome: The API should restrict access to administrative endpoints to authorized users.\nAPI6: Unrestricted Access to Sensitive Business Flows\nCheckpoint 1: Automated Attack Detection\nTest: Use automated tools to send a large number of requests to the API in a short period. Try to identify patterns in the API's responses that could indicate an automated attack.\nExpected Outcome: The API should implement mechanisms to detect and prevent automated attacks. For example, the API could use rate limiting, CAPTCHAs, or other techniques to identify and block automated requests.\nCheckpoint 2: Human Behavior Analysis\nTest: Send requests to the API that mimic human behavior. For example, try to send requests with varying intervals between them and with different user agents.\nExpected Outcome: The API should be able to distinguish between human and automated requests. The API could use techniques like session management, user agent analysis, or behavioral analysis to identify and prevent malicious requests.\nAPI7: Server Side Request Forgery\nCheckpoint 1: URI Validation\nTest: Send requests with malicious URIs that could potentially exploit the API's server-side request forgery vulnerability. For example, try to send a request with a URI that points to a restricted page, a local file, or a content file.\nExpected Outcome: The API should validate all URIs and prevent attackers from exploiting server-side request forgery vulnerabilities.\nCheckpoint 2: Restricting External Requests\nTest: Attempt to make the API fetch resources from external domains or URLs that are not allowed.\nExpected Outcome: The API should restrict the ability to fetch resources from external domains or URLs that are not allowed.\nCheckpoint 3: Local File Access Prevention\nTest: Attempt to make the API fetch local files from the server.\nExpected Outcome: The API should prevent attackers from accessing local files on the server.\nAPI8: Security Misconfiguration\nCheckpoint 1: Error Handling\nTest: Send requests that are likely to cause errors and analyze the API's error responses. Look for sensitive information that might be revealed in error messages.\nExpected Outcome: The API should handle errors gracefully and should not reveal sensitive information in error messages.\nCheckpoint 2: Configuration Auditing\nTest: Use security tools to scan the API's configuration for potential vulnerabilities.\nExpected Outcome: The API's configuration should be secure and should not contain any vulnerabilities.\nCheckpoint 3: Secure Defaults\nTest: Verify that the API is using secure defaults for its configuration. For example, the API should use strong encryption algorithms, secure protocols, and robust authentication mechanisms.\nExpected Outcome: The API should be configured with secure defaults to minimize the risk of vulnerabilities.\nAPI9: Improper Inventory Management\nCheckpoint 1: API Documentation\nTest: Review the API documentation to ensure that it is up-to-date and accurate. Check for any missing or outdated information.\nExpected Outcome: The API documentation should be complete, accurate, and up-to-date.\nCheckpoint 2: Deprecated Endpoints\nTest: Attempt to access deprecated endpoints.\nExpected Outcome: The API should not expose deprecated endpoints.\nCheckpoint 3: Debug Endpoints\nTest: Attempt to access debug endpoints.\nExpected Outcome: The API should not expose debug endpoints.\nCheckpoint 4: Sensitive Information in Documentation\nTest: Review the API documentation to ensure that it does not expose sensitive information.\nExpected Outcome: The API documentation should not expose sensitive information.\nAPI10: Unsafe Consumption of APIs\nCheckpoint 1: Input Validation and Sanitization\nTest: Send requests to the API with data that is received from third-party APIs. Try to inject malicious data into the requests.\nExpected Outcome: The API should validate and sanitize all data that is received from third-party APIs.\nCheckpoint 2: Resource Consumption Limits\nTest: Send requests to the API that consume a large amount of resources. Try to exceed the API's resource limits.\nExpected Outcome: The API should implement resource limits to prevent attackers from overloading the server.",
      ],
    },
    {
      "role": "model",
      "parts": [
        "This is a great starting point for understanding OWASP TOP 10 API 2023 vulnerabilities and how to test for them. You have clearly outlined the vulnerabilities and provided practical checkpoints with test cases and expected outcomes. \n\nHere's a breakdown of your provided list, highlighting some key points and how we can modify queries to test for these vulnerabilities:\n\n**API1: Broken Object Level Authorization**\n\n* **Checkpoint 1: Method-Based Access Control**\n    * **Original Query:** (Assuming you're trying to fetch a resource) `GET /resource/123`\n    * **Modified Query:** `DELETE /resource/123` (If only GET is authorized, this should fail)\n\n* **Checkpoint 2: Content-Type Validation**\n    * **Original Query:** (Assuming you're sending JSON) `POST /resource` with `Content-Type: application/json` and JSON payload\n    * **Modified Query:** `POST /resource` with `Content-Type: text/plain` and the same JSON payload (Should be rejected)\n\n* **Checkpoint 3: UUID Predictability**\n    * **Original Query:** `GET /resource/{uuid}` (Where {uuid} is a known UUID)\n    * **Modified Query:** `GET /resource/{uuid}` (Try predicting the next UUID based on patterns in the API responses)\n\n**API2: Broken Authentication**\n\n* **Checkpoint 1: Password Strength**\n    * **Original Query:** (Assuming registration endpoint) `POST /register` with strong password\n    * **Modified Query:** `POST /register` with weak passwords (Should be rejected)\n\n* **Checkpoint 2: Authentication Rate Limiting**\n    * **Original Query:** `POST /login` with valid credentials\n    * **Modified Query:** Send multiple `POST /login` requests with invalid credentials within a short period (Should be rate-limited)\n\n* **Checkpoint 3: Token Validation**\n    * **Original Query:** (Assuming JWT token is used) `GET /protected-resource` with valid JWT token\n    * **Modified Query:** `GET /protected-resource` with manipulated JWT token (Modified payload, signature, etc.)\n    * **Original Query:** (Assuming OAuth/OpenID) Obtain access token with valid credentials \n    * **Modified Query:** Try to obtain unauthorized access token or refresh token (e.g., by exploiting vulnerabilities in OAuth flow)\n\n**API3: Broken Object Property Level Authorization**\n\n* **Checkpoint 1: Excessive Data Exposure**\n    * **Original Query:** `GET /user/123`\n    * **Modified Query:** Analyze the response for sensitive information like password, private messages, etc.\n\n* **Checkpoint 2: Input Validation**\n    * **Original Query:** `POST /user` with valid payload\n    * **Modified Query:** `POST /user` with invalid or unexpected parameters and payloads (Should be rejected)\n\n* **Checkpoint 3: Server-Side Filtering**\n    * **Original Query:** (Assuming a search functionality) `GET /search?query=value`\n    * **Modified Query:** `GET /search?query=value%20OR%201=1` (Attempting to bypass filtering with SQL injection) \n\n**API4: Unrestricted Resource Consumption**\n\n* **Checkpoint 1: Rate Limiting**\n    * **Original Query:** `GET /resource`\n    * **Modified Query:** Send a large number of `GET /resource` requests within a short period (Should be rate-limited)\n\n* **Checkpoint 2: Payload Limits**\n    * **Original Query:** `POST /resource` with a valid payload \n    * **Modified Query:** `POST /resource` with large payloads exceeding the limit (Should be rejected)\n\n* **Checkpoint 3: Compression**\n    * **Original Query:** `GET /resource` with a large payload\n    * **Modified Query:** Analyze the response for compression (Content-Encoding header)\n\n**API5: Broken Function Level Authorization**\n\n* **Checkpoint 1: Method-Based Authorization**\n    * **Original Query:** `GET /resource/123` (To fetch resource)\n    * **Modified Query:** `DELETE /resource/123` (To delete resource, if only GET is authorized, this should fail)\n\n* **Checkpoint 2: Role-Based Access Control**\n    * **Original Query:** (Assuming user with specific role) `GET /admin/resource`\n    * **Modified Query:** (Assuming user with a different role) `GET /admin/resource` (Should be forbidden)\n\n* **Checkpoint 3: Administrative Endpoint Protection**\n    * **Original Query:** (Assuming you're a regular user) `GET /admin/dashboard`\n    * **Modified Query:** (Attempting to access an administrative endpoint) `GET /admin/dashboard` (Should be forbidden)\n\n**API6: Unrestricted Access to Sensitive Business Flows**\n\n* **Checkpoint 1: Automated Attack Detection**\n    * **Original Query:** (Normal user interaction) `GET /resource`\n    * **Modified Query:** Use automated tools to send a large number of `GET /resource` requests within a short period (Should be detected and potentially blocked)\n\n* **Checkpoint 2: Human Behavior Analysis**\n    * **Original Query:** (Normal user interaction) `GET /resource`\n    * **Modified Query:** Send requests with varying intervals, different user agents, etc. (To try to bypass automated detection)\n\n**API7: Server Side Request Forgery**\n\n* **Checkpoint 1: URI Validation**\n    * **Original Query:** (Assuming an image upload endpoint) `POST /upload` with valid image data \n    * **Modified Query:** `POST /upload` with malicious URIs (e.g., `http://example.com/admin.php?action=delete`)\n    * **Modified Query:** `POST /upload` with malicious URI pointing to local file (e.g., `file:///etc/passwd`)\n\n* **Checkpoint 2: Restricting External Requests**\n    * **Original Query:** (Assuming the API can fetch external resources) `GET /fetch?url=https://example.com`\n    * **Modified Query:** `GET /fetch?url=http://malicious.com/` (To try to fetch resources from unauthorized domains)\n\n* **Checkpoint 3: Local File Access Prevention**\n    * **Original Query:** (Assuming the API can fetch local resources) `GET /fetch?url=file:///etc/passwd`\n    * **Modified Query:** `GET /fetch?url=file:///etc/passwd` (To try to fetch local files from the server)\n\n**API8: Security Misconfiguration**\n\n* **Checkpoint 1: Error Handling**\n    * **Original Query:** (Normal request) `GET /resource`\n    * **Modified Query:** Send requests that are likely to cause errors (e.g., invalid parameters, missing data) and analyze the error responses for sensitive information.\n\n* **Checkpoint 2: Configuration Auditing**\n    * **Original Query:** (Not a query, but rather a security tool scan) Use security tools to scan the API configuration for vulnerabilities.\n\n* **Checkpoint 3: Secure Defaults**\n    * **Original Query:** (Not a query, but rather a manual review) Verify the API's configuration for secure defaults like encryption algorithms, protocols, and authentication methods.\n\n**API9: Improper Inventory Management**\n\n* **Checkpoint 1: API Documentation**\n    * **Original Query:** (Not a query, but rather a review) Review the API documentation for completeness, accuracy, and up-to-dateness.\n\n* **Checkpoint 2: Deprecated Endpoints**\n    * **Original Query:** (Attempting to access deprecated endpoint) `GET /deprecated/resource`\n\n* **Checkpoint 3: Debug Endpoints**\n    * **Original Query:** (Attempting to access debug endpoint) `GET /debug/resource`\n\n* **Checkpoint 4: Sensitive Information in Documentation**\n    * **Original Query:** (Not a query, but rather a review) Review the API documentation for sensitive information leaks.\n\n**API10: Unsafe Consumption of APIs**\n\n* **Checkpoint 1: Input Validation and Sanitization**\n    * **Original Query:** (Assuming the API receives data from a third-party API) `POST /process` with data received from third-party API.\n    * **Modified Query:** Inject malicious data into the request from the third-party API (Should be validated and sanitized)\n\n* **Checkpoint 2: Resource Consumption Limits**\n    * **Original Query:** (Normal request) `GET /resource`\n    * **Modified Query:** Send requests that consume a large amount of resources (e.g., excessive iterations, complex queries)\n\nThis is a comprehensive framework. Remember, your specific test cases and queries will be highly dependent on the API you are testing and the specific implementation of its features. You should tailor your tests to the individual API you're assessing.\n",
      ],
    },
  ]
)
# Create your views here.

def vulnChecking(endpoints,checkpoints) :
    scan_result = dict() # (E1,P1):[baseRequest,MRequest,MResponse,Status]
    for endpoint_id in endpoints :
        endpoint = Endpoint.objects.filter(id=endpoint_id).first()
        for checkpoint_id in checkpoints:
            checkpoint = SecurityCheckpoint.objects.filter(id=checkpoint_id).first()
            scan_result[(endpoint.id,checkpoint.id)]=[]
    checkpoint_list=[]
    for checkpoint_id in checkpoints :
        checkpoint = SecurityCheckpoint.objects.filter(id=checkpoint_id).first()
        checkpoint_list.append(checkpoint.Description)
    for endpoint_id in endpoints :
        endpoint=Endpoint.objects.filter(id=endpoint_id).first()
        #baseRequest={}
        #baseRequest['url'] = endpoint.url
        #baseRequest['method'] = endpoint.verb
        #baseRequest['header'] = endpoint.header
        #baseRequest['body'] = endpoint.parameters
        baseRequest = ApiRequest(endpoint.url,endpoint.verb.upper(),str_to_dict(endpoint.header),endpoint.parameters)
        #requestForPrompt = "Method:{"+f"{endpoint.verb}"+"} Header:{" + f"{endpoint.header}" +"} Body:{"+f"{endpoint.parameters}"+"}"
        malformed_requests=generate_malformed_requests(baseRequest,checkpoint_list).splitlines()
        i=0
        for checkpoint_id in checkpoints:
            checkpoint = SecurityCheckpoint.objects.filter(id=checkpoint_id).first()
            scan_result[(endpoint.id,checkpoint.id)].append(baseRequest)
            if malformed_requests[i]=='NA':
                malformed_request=ApiRequest(endpoint.url,'NA','NA')
                status='NOT'
            else  :
                #tmp = extractMHB(tmpDict)
                tmpDict=ast.literal_eval(str(malformed_requests[i]))
                method = tmpDict['Method']
                headers = ast.literal_eval(str(tmpDict['Headers']))
                body = ast.literal_eval(str(tmpDict['Body']))
                status=random.choice(['YES','NO'])
                malformed_request = ApiRequest(endpoint.url,method,headers,body)
                #print(type(malformed_request.headers))
                #print(baseRequest.headers)
                baseResponse = baseRequest.send()
                malformed_response = malformed_request.send()
                #print(baseResponse)
                #print("\n")
                #print(malformed_response)
            scan_result[(endpoint.id,checkpoint.id)].append(malformed_request)
            scan_result[(endpoint.id,checkpoint.id)].append(baseResponse)
            scan_result[(endpoint.id,checkpoint.id)].append(malformed_response)
            scan_result[(endpoint.id,checkpoint.id)].append(status)
            #print(malformed_request)
            i+=1
    return scan_result

def generate_malformed_requests(normal_request,checkpointlist):
    modifiedRequest = malformedRequest(chat_session,normal_request,checkpointlist)
    #print(modifiedRequest)
    return modifiedRequest

def vulnHome(request):
    # Si le formulaire est rempli
    context = {
              'collections':APICollection.objects.all(),
              'endpoints':Endpoint.objects.all(),
              'vulnerability':Vulnerability.objects.all(),
              'securityCheckpoints':SecurityCheckpoint.objects.all(),
    }
    if request.POST.get('scanName') :
        context['scanName']=request.POST.get('scanName')
        checkedEndpoints = [request.POST.get(key) for key in request.POST if key.startswith('endpoint-')]
        context['checkedEndpoints'] = [Endpoint.objects.filter(id=id).first() for id in checkedEndpoints]
        checkpoints = [request.POST.get(key) for key in request.POST if key.startswith('checkpoint-')]
        context['checkpoints'] = [Endpoint.objects.filter(id=id).first() for id in checkpoints]
        context['apiCollection']=APICollection.objects.filter(id=request.POST.get('selectAPI')).first()
        scan_result=vulnChecking(checkedEndpoints,checkpoints)
        for k in scan_result.keys():
            endpoint = Endpoint.objects.filter(id=k[0]).first()
            checkpoint = SecurityCheckpoint.objects.filter(id=k[1]).first()
            temp = Scan(Name=request.POST.get('scanName'),Endpoint=endpoint,SecurityCheckpoint=checkpoint,BaseRequest=scan_result[k][0],ModifiedRequest=scan_result[k][1],BaseResponse=scan_result[k][2],ModifiedResponse=scan_result[k][3],Status=scan_result[k][4])
            temp.save()
        return redirect(f"scanResult/{context['scanName']}")
    else :
    # Sinon
      endpoints = dict()
      for collection in APICollection.objects.all():
          endpoints[collection.name] = Endpoint.objects.all().filter(api=collection)
      #print(f"bou {chat_session}")
      return render(request,'vuln_checking/vulnHome.html',context)
    

def getEndpoints(request):
    api_id = request.GET.get('api_id')
    #print(api_id)
    if api_id:
        endpoints = Endpoint.objects.filter(api_id=api_id)
    else:
        endpoints = []

    return render(request, 'vuln_checking/endpoints.html', {'endpoints': endpoints})

def vulnDesc(request,vulnId):
    context = {
        'collections':APICollection.objects.all(),
        'endpoints':Endpoint.objects.all(),
    }
    vuln = Vulnerability.objects.filter(id=vulnId).first()
    context['vuln']=vuln
    return render(request,'vuln_checking/vulnDesc.html',context)

def checkDesc(request,checkId):
    context = {
        'collections':APICollection.objects.all(),
        'endpoints':Endpoint.objects.all(),
        'checkpoint':SecurityCheckpoint.objects.filter(id=checkId).first()
    }
    #print(context['checkpoint'])
    return render(request,'vuln_checking/checkDesc.html',context)


def resultDesc(request,scan_name):
    context = {
        'collections':APICollection.objects.all(),
        'endpoints':Endpoint.objects.all(),
        'scanName':scan_name
    }
    Scans = Scan.objects.filter(Name=scan_name)
    context['checkedEndpoints']=set()
    checkedEndpoints = set()
    endpointsName =  set()
    
    statutsGlobal=dict()
    statutsGlobal['YES']=0
    statutsGlobal['NO']=0
    statutsGlobal['NOT']=0

    statusByEndpoint = dict()
    yesByCheckpoint = dict()
    noByCheckpoint = dict()
    notByCheckpoint = dict()
    ratios=[]
    for scan in Scans :
        checkedEndpoints.add(scan.Endpoint)
        endpointsName.add(scan.Endpoint.name)

        statutsGlobal[scan.Status]+=1
        if scan.Endpoint.id in statusByEndpoint.keys():
            if scan.Status=='YES':
                statusByEndpoint[scan.Endpoint.id][0]+=1
            elif scan.Status=='NO':
                statusByEndpoint[scan.Endpoint.id][1]+=1
            else :
                scan.Status=='YES'
                statusByEndpoint[scan.Endpoint.id][2]+=1
        else :
            statusByEndpoint[scan.Endpoint.id]=[0,0,0]
            if scan.Status=='YES':
                statusByEndpoint[scan.Endpoint.id][0]=1
            elif scan.Status=='NO':
                statusByEndpoint[scan.Endpoint.id][1]=1
            else :
                scan.Status=='YES'
                statusByEndpoint[scan.Endpoint.id][2]=1

        if scan.SecurityCheckpoint.Name in yesByCheckpoint.keys():
            if scan.Status=='YES':
                yesByCheckpoint[scan.SecurityCheckpoint.Name]+=1
        else :
            if scan.Status=='YES':
               yesByCheckpoint[scan.SecurityCheckpoint.Name]=1
        
        if scan.SecurityCheckpoint.Name in noByCheckpoint.keys():
            if scan.Status=='NO':
                noByCheckpoint[scan.SecurityCheckpoint.Name]+=1
        else :
            if scan.Status=='NO':
               noByCheckpoint[scan.SecurityCheckpoint.Name]=1
        
        if scan.SecurityCheckpoint.Name in notByCheckpoint.keys():
            if scan.Status=='NOT':
                notByCheckpoint[scan.SecurityCheckpoint.Name]+=1
        else :
            if scan.Status=='NOT':
               notByCheckpoint[scan.SecurityCheckpoint.Name]=1
    for s in statusByEndpoint.keys():
        ratio = (statusByEndpoint[s][0]/(statusByEndpoint[s][0]+statusByEndpoint[s][1]))*100
        statusByEndpoint[s].append(int(ratio))
        ratios.append(int(ratio)/100)
    #print(statusByEndpoint)
    context['apiCollectionName']=Scans.first().Endpoint.api
    context['statutsGlobal']=json.dumps(statutsGlobal,cls=DjangoJSONEncoder)
    context['checkedEndpoints'] = checkedEndpoints
    context['statusByEndpoint'] = statusByEndpoint
    context['yesByCheckpoint'] = json.dumps(yesByCheckpoint,cls=DjangoJSONEncoder)
    context['noByCheckpoint'] =  json.dumps(noByCheckpoint,cls=DjangoJSONEncoder)
    context['notByCheckpoint'] = json.dumps(notByCheckpoint,cls=DjangoJSONEncoder)
    context['EndpointsName'] = list(endpointsName)
    context['ratios']=ratios
    #print(endpointsName)
    #print(Endpoint.objects.filter(id=15).first().name)
    riskByCheckpoints=dict()
    for endpoint_id in statusByEndpoint:
        temp=[0]*len(SecurityCheckpoint.objects.all())
        Scans = Scan.objects.filter(Name=scan_name)
        s_temp=Scans.filter(Endpoint=Endpoint.objects.filter(id=endpoint_id).first()).filter(Status='NO').all()
        for scan in s_temp:
            sec_checkpoint=int(scan.SecurityCheckpoint.Name.split('P')[1])
            temp[sec_checkpoint-1]=scan.impactScore
        riskByCheckpoints[Endpoint.objects.filter(id=endpoint_id).first().name]=temp
        #print(len(temp))
    #print(riskByCheckpoints)
    context['riskByCheckpoints']=json.dumps(riskByCheckpoints,cls=DjangoJSONEncoder)
    return render(request,'vuln_checking/resultDesc.html',context=context)

def detailResult(request,scan_name,endpoint_id):
    context = {
        'collections':APICollection.objects.all(),
        'endpoints':Endpoint.objects.all(),
        'scan_name':scan_name,
        'endpoint':Endpoint.objects.filter(id=endpoint_id).first()
    }
    endpoint = Endpoint.objects.filter(id=endpoint_id).first()
    
    context['checkpoints']=set()
    Scans = Scan.objects.filter(Name=scan_name)
    context['choosedCheckpoint']=0
    for scan in Scans:
        context['checkpoints'].add(scan.SecurityCheckpoint)

    if request.method == 'POST':
        action=request.POST.get('action')
        if action=='Save':
           #print("save")
           checkpoint=SecurityCheckpoint.objects.filter(id=request.POST.get('checkpoint')).first()
           #scan=Scan.objects.filter(Name=scan_name).filter(Endpoint=endpoint).filter(SecurityCheckpoint=checkpoint).first()
           scan = Scan.objects.get(Name=scan_name,Endpoint=endpoint,SecurityCheckpoint=checkpoint)
           scan.Status=request.POST.get('status')
           nMethod=request.POST.get('mMethod')
           nURL=request.POST.get('mURL')
           nHeader=request.POST.get('mheader')
           nBody=request.POST.get('mBody')
           nRequest = ApiRequest(nURL,nMethod,nHeader,nBody)
           scan.ModifiedRequest=nRequest
           if request.POST.get('status')=='NO':
               scan.ImpactConfidentiality=request.POST.get('C_impact')
               scan.ImpactIntegrity=request.POST.get('I_impact')
               scan.ImpactAvailability=request.POST.get('A_impact')
           scan.save() 
           return redirect(f"/vulnchecking/scanResult/{scan_name}")
        elif action=='Send':
            endpoint_name=request.POST.get('endpoint_name')
            scan_name=request.POST.get('scan_name')
            method=request.POST.get('mMethod')
            headers=ast.literal_eval(request.POST.get('mheader'))
            body=ast.literal_eval(request.POST.get('mBody'))
            url=request.POST.get('mURL')
            req=ApiRequest(url,method,headers,body)
            resp=req.send()
            selectedCheckpoint=request.POST.get('checkpoint')
            choosedScan=Scan.objects.filter(Name=scan_name).filter(Endpoint=Endpoint.objects.filter(name=endpoint_name).first()).filter(SecurityCheckpoint=SecurityCheckpoint.objects.filter(id=selectedCheckpoint).first()).first()
            choosedScan.ModifiedRequest=req
            choosedScan.ModifiedResponse=resp
            #print(resp)
            #print(selectedCheckpoint)
            context['choosedCheckpoint']=selectedCheckpoint
            choosedScan.save()
    return render(request,'vuln_checking/detailDesc.html',context)

def get_text_area_values(request):
    #print(request.keys())
    #checkpoint=SecurityCheckpoint.objects.filter(Name=f'P-{request.GET.get('checkpoint')}').first()
    #endpoint = Endpoint.objects.filter(id=request.GET.get('endpoint')).first()
    checkpoint=request.GET.get('checkpoint')
    endpoint = request.GET.get('endpoint')
    scan_name = request.GET.get('scan')
    scan = Scan.objects.filter(Name=scan_name,Endpoint=endpoint,SecurityCheckpoint=checkpoint).first()
    owaspRiskScore=scan.SecurityCheckpoint.Vulnerability.riskScore
    #print(scan.BaseResponse)
    return JsonResponse({'baseURL':scan.BaseRequest.url,'baseMethod':scan.BaseRequest.method.upper(),'baseHeader':str(scan.BaseRequest.headers),'baseBody':str(scan.BaseRequest.body),'mURL':scan.ModifiedRequest.url,'mMethod':scan.ModifiedRequest.method,'mHeader':str(scan.ModifiedRequest.headers),'mBody':str(scan.ModifiedRequest.body),'status':scan.Status,'impactConfidentiality':scan.ImpactConfidentiality,'impactIntegrity':scan.ImpactIntegrity,'impactAvailability':scan.ImpactAvailability,'impactScore':scan.impactScore,'owaspRiskScore':owaspRiskScore,'vuln':scan.SecurityCheckpoint.Vulnerability.Name,'baseResponse':scan.BaseResponse,'modifiedResponse':scan.ModifiedResponse})
    